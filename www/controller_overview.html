<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>LED Driver Overview</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        margin: 0;
        padding: 2rem;
        background: #111827;
        color: #e5e7eb;
      }
      h1 {
        margin-top: 0;
        font-size: 2rem;
      }
      .hint {
        color: rgba(229, 231, 235, 0.65);
        margin-bottom: 1rem;
      }
      .table-wrapper {
        overflow-x: auto;
      }
      table.controller-table {
        width: 100%;
        border-collapse: collapse;
        background: rgba(30, 41, 59, 0.7);
        border-radius: 0.75rem;
        overflow: hidden;
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.35);
      }
      table.controller-table thead {
        background: rgba(59, 130, 246, 0.25);
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 0.75rem;
      }
      table.controller-table th,
      table.controller-table td {
        padding: 0.75rem 1rem;
        text-align: left;
      }
      table.controller-table tbody tr:nth-child(even) {
        background: rgba(30, 41, 59, 0.5);
      }
      table.controller-table tbody tr:hover {
        background: rgba(59, 130, 246, 0.15);
      }
      table.controller-table td.power {
        font-weight: 600;
      }
      .switch-visual {
        margin: 1.5rem 0 2rem;
        padding: 1rem 1.5rem 1.75rem;
        background: rgba(30, 41, 59, 0.7);
        border-radius: 0.75rem;
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.35);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.75rem;
      }
      .switch-visual label {
        font-size: 0.95rem;
        color: rgba(229, 231, 235, 0.8);
      }
      .switch-visual select {
        padding: 0.5rem 0.75rem;
        border-radius: 0.5rem;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(17, 24, 39, 0.8);
        color: #e5e7eb;
        min-width: 220px;
      }
      .switch-visual-image {
        max-width: 100%;
        width: 100%;
        border-radius: 0.5rem;
        border: 1px solid rgba(148, 163, 184, 0.35);
        display: block;
        user-select: none;
        -webkit-user-drag: none;
      }
      .switch-visual-viewport {
        position: relative;
        width: min(100%, 280px);
      }
      .switch-button-layer {
        position: absolute;
        inset: 0;
        pointer-events: auto;
      }
      .switch-button {
        position: absolute;
        width: 22%;
        aspect-ratio: 1/1;
        background: url("led_driver_panel/Button.jpg") center/contain no-repeat;
        transform: translate(-50%, -50%);
        pointer-events: auto;
        cursor: pointer;
      }
      .switch-button::after {
        content: "";
        position: absolute;
        inset: 13%;
        border-radius: 50%;
        border: 4px solid rgba(148, 163, 184, 0.35);
        background: transparent;
        transform: translate(-1px, -2px);
        opacity: 0;
        transition: opacity 120ms ease, border-color 120ms ease, background 120ms ease;
        pointer-events: none;
      }
      .switch-button.is-on::after {
        opacity: 1;
        border-color: #34d399;
      }
      .led-matrix {
        margin-top: 2rem;
        background: rgba(30, 41, 59, 0.7);
        border-radius: 0.75rem;
        padding: 1rem;
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.35);
      }
      .led-matrix h2 {
        margin: 0 0 0.5rem;
        font-size: 1.1rem;
      }
      .led-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(18px, 1fr));
        gap: 6px;
      }
      .led-dot {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #0f172a;
        border: 1px solid rgba(148, 163, 184, 0.4);
        cursor: pointer;
        position: relative;
        transition: box-shadow 120ms ease, transform 120ms ease;
      }
      .led-dot.on {
        background: #22c55e;
        box-shadow: 0 0 6px rgba(34, 197, 94, 0.8);
      }
      .led-dot.fault {
        background: #ef4444;
        box-shadow: 0 0 6px rgba(239, 68, 68, 0.7);
      }
      .led-dot:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.35);
      }
      .led-dot::after {
        content: attr(data-tooltip);
        position: absolute;
        left: 50%;
        bottom: 125%;
        transform: translateX(-50%);
        background: rgba(15, 23, 42, 0.95);
        color: #e5e7eb;
        padding: 4px 6px;
        border-radius: 4px;
        font-size: 10px;
        white-space: pre;
        opacity: 0;
        pointer-events: none;
        transition: opacity 120ms ease;
        z-index: 10;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
      }
      .led-dot:hover::after {
        opacity: 1;
      }
      .footer-version {
        margin-top: 1.5rem;
        text-align: right;
        color: rgba(229, 231, 235, 0.7);
        font-size: 0.9rem;
      }
      .switch-slider {
        width: min(100%, 280px);
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        align-items: stretch;
        margin-top: 0.6rem;
      }
      .switch-slider label {
        font-size: 0.9rem;
        color: rgba(229, 231, 235, 0.8);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .switch-slider input[type="range"] {
        width: 100%;
        accent-color: #3b82f6;
      }
    </style>
  </head>
  <body>
    <main class="container">
      <h1>LED Driver Controllers</h1>
      <!-- Debug control block: easy to comment out to disable -->
      <div style="margin-bottom: 0.5rem; display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
        <!--label style="display: inline-flex; align-items: center; gap: 0.5rem; cursor: pointer;">
          <input type="checkbox" id="toggle-refresh" checked />
          <span>Auto refresh</span>
        </label>
        <button id="manual-refresh" style="padding: 0.4rem 0.75rem; border: 1px solid rgba(148,163,184,0.4); border-radius: 0.5rem; background: rgba(59,130,246,0.2); color: #e5e7eb; cursor: pointer;">
          Refresh now
        </button-->
        <span class="hint" id="status" style="margin: 0;">Loading…</span>
      </div>
      <section class="switch-visual">
        <label for="overview-switch-select">Select Switch</label>
        <select id="overview-switch-select"></select>
        <div class="switch-visual-viewport">
          <img src="led_driver_panel/blank.jpg" alt="Switch layout" class="switch-visual-image" draggable="false" />
          <div class="switch-button-layer" id="switch-button-layer"></div>
        </div>
        <div class="switch-slider">
          <label for="switch-brightness">
            Brightness
            <span id="switch-brightness-value">0</span>
          </label>
          <input type="range" id="switch-brightness" min="0" max="100" step="1" value="0" disabled />
        </div>
      </section>
      <section class="led-matrix">
        <h2>LED Matrix</h2>
        <div class="led-grid" id="led-grid"></div>
      </section>
      <div class="table-wrapper">
        <table class="controller-table" id="controller-table">
          <thead>
            <tr>
              <th>Controller</th>
              <th>Power</th>
              <th>LEDs On</th>
              <th>Faulty LEDs</th>
              <th>Total LEDs</th>
              <th>Current</th>
              <th>Voltage</th>
            </tr>
          </thead>
          <tbody id="controller-list"></tbody>
        </table>
      </div>
      <div class="footer-version">Panel version: <span id="panel-version">loading…</span></div>
    </main>

    <script>
      const state = {
        entryId: null,
        controllers: [],
        drivers: [],
        switches: [],
        groups: [],
        buttons: [],
      };

      const statusEl = document.getElementById("status");
      const listEl = document.getElementById("controller-list");
      const switchSelect = document.getElementById("overview-switch-select");
      const switchButtonLayer = document.getElementById("switch-button-layer");
      const brightnessSlider = document.getElementById("switch-brightness");
      const brightnessValue = document.getElementById("switch-brightness-value");
      const ledGrid = document.getElementById("led-grid");
      const panelVersionEl = document.getElementById("panel-version");
      const buttonInteractionState = new Map();
      let lastActiveGroupId = null;

      const SWITCH_BUTTON_POSITIONS = {
        1: [{ x: 50, y: 50 }],
        3: [
          { x: 50, y: 32 },
          { x: 50, y: 50 },
          { x: 50, y: 68 },
        ],
        5: [
          { x: 50, y: 50 },
          { x: 32, y: 32 },
          { x: 68, y: 32 },
          { x: 32, y: 68 },
          { x: 68, y: 68 },
        ],
      };

      function resolveHass() {
        const parent = window.parent;
        if (!parent) {
          return null;
        }
        if (parent.hass) {
          return parent.hass;
        }
        try {
          const root = parent.document?.querySelector("home-assistant");
          if (root?.hass) {
            return root.hass;
          }
          const main = root?.shadowRoot?.querySelector("home-assistant-main");
          if (main?.hass) {
            return main.hass;
          }
        } catch (error) {
          console.debug("Failed to resolve hass instance", error);
        }
        return null;
      }

      async function waitForHass(timeoutMs = 5000) {
        const interval = 100;
        const deadline = Date.now() + timeoutMs;
        while (true) {
          if (resolveHass()) {
            return;
          }
          if (Date.now() > deadline) {
            throw new Error("Timed out waiting for Home Assistant context");
          }
          await new Promise((resolve) => setTimeout(resolve, interval));
        }
      }

      async function callApi(method, path, body) {
        const hass = resolveHass();
        if (!hass?.callApi) {
          throw new Error("Home Assistant API unavailable");
        }
        return hass.callApi(method, path.startsWith("/api/") ? path.slice(5) : path, body);
      }

      function computeControllerSummaries() {
        const driversByController = new Map();
        state.drivers.forEach((driver) => {
          const controllerId = driver.controller_id;
          if (!controllerId) {
            return;
          }
          if (!driversByController.has(controllerId)) {
            driversByController.set(controllerId, []);
          }
          driversByController.get(controllerId).push(driver);
        });

        return state.controllers.map((controller) => {
          const status = controller.metadata?.status || {};
          const summary = {
            id: controller.id,
            name: controller.name || controller.id,
            power: status.total_power,
            current: status.total_current,
            voltage: status.total_voltage,
            led_total: 0,
            led_on: 0,
            led_fault: 0,
          };

          const drivers = driversByController.get(controller.id) || [];
          drivers.forEach((driver) => {
            (driver.outputs || []).forEach((output) => {
              if (output.disabled) {
                return;
              }
              summary.led_total += 1;
              if (Number(output.level || 0) > 0) {
                summary.led_on += 1;
              }
              if (output.faulty) {
                summary.led_fault += 1;
              }
            });
          });

          return summary;
        });
      }

      function formatNumber(value, decimals = 2) {
        if (!Number.isFinite(Number(value))) {
          return "—";
        }
        return Number(value).toFixed(decimals);
      }

      function getSwitchButtonCount(entry) {
        if (!entry || typeof entry !== "object") {
          return 5;
        }
        let candidate = entry.button_count;
        if (candidate === undefined && entry.metadata && typeof entry.metadata === "object") {
          candidate = entry.metadata.button_count;
        }
        const value = Number.parseInt(candidate, 10);
        if (!Number.isFinite(value)) {
          return 5;
        }
        if (value < 1) return 1;
        if (value > 5) return 5;
        return value;
      }

      function findSwitchByValue(value) {
        if (!value) return null;
        const entries = state.switches || [];
        return entries.find((entry) => String(entry.switch ?? "") === String(value)) || null;
      }

      function findButtonsForSwitch(switchEntry) {
        if (!switchEntry) {
          return [];
        }
        const entries = state.buttons || [];
        const switchId = switchEntry.id;
        const switchValue = switchEntry.switch;
        return entries
          .filter((button) => {
            if (switchId && button.switch_id === switchId) {
              return true;
            }
            return String(button.switch ?? "") === String(switchValue ?? "");
          })
          .sort((a, b) => Number(a.mask || 0) - Number(b.mask || 0));
      }

      function getGroupById(groupId) {
        if (!groupId) return null;
        return (state.groups || []).find((g) => g.id === groupId) || null;
      }

      function upsertGroupPartial(groupId, updates) {
        if (!groupId) return;
        const groups = state.groups || [];
        let found = false;
        for (let i = 0; i < groups.length; i += 1) {
          if (groups[i].id === groupId) {
            groups[i] = { ...groups[i], ...updates };
            found = true;
            break;
          }
        }
        if (!found) {
          groups.push({ id: groupId, ...updates });
        }
        state.groups = groups;
      }

      function applyStateChangeFromEvent(event) {
        const newState = event?.data?.new_state;
        if (!newState) return false;
        console.log("Applying state change for", newState.entity_id);
        const attrs = newState.attributes || {};
        const groupId = attrs.group_id;
        console.log("Group ID:", groupId);
        if (!groupId) return false;
        const isOn = newState.state === "on" || !!attrs.is_on;
        let brightness = attrs.brightness;
        if (!Number.isFinite(Number(brightness))) {
          brightness = undefined;
        } else {
          brightness = Math.max(0, Math.min(100, Number(brightness)));
        }
        const updates = { is_on: isOn };
        console.log("Updating group", groupId, "is_on =", isOn, "brightness =", brightness);
        if (brightness !== undefined) {
          updates.brightness = brightness;
        }
        upsertGroupPartial(groupId, updates);
        renderSwitchButtons(switchSelect.value || null);
        console.log("Redered switch buttons after state change");
        if (lastActiveGroupId === groupId) {
          setActiveGroup(groupId);
        }
        return true;
      }

      function applyGroupBusEvent(data) {
        if (!data || !data.group_id) {
          return false;
        }
        const updates = {
          is_on: !!data.is_on,
        };
        if (data.brightness !== undefined) {
          const b = Number(data.brightness);
          if (Number.isFinite(b)) {
            updates.brightness = Math.max(0, Math.min(100, b));
          }
        }
        upsertGroupPartial(data.group_id, updates);
        renderSwitchButtons(switchSelect.value || null);
        if (lastActiveGroupId === data.group_id) {
          setActiveGroup(data.group_id);
        }
        renderLedMatrix();
        return true;
      }

      function buildOutputIndex() {
        const index = new Map();
        (state.drivers || []).forEach((driver) => {
          (driver.outputs || []).forEach((output) => {
            if (output.id) {
              index.set(output.id, { driver, output });
            }
          });
        });
        return index;
      }

      function buttonStateKey(switchValue, mask) {
        return `${switchValue ?? ""}:${mask ?? ""}`;
      }

      function getGroupOutputs(groupId) {
        const group = getGroupById(groupId);
        if (!group) return [];
        const ids = group.led_ids || [];
        const index = buildOutputIndex();
        return ids
          .map((id) => index.get(id))
          .filter(Boolean)
          .map((entry) => entry.output);
      }

      function getGroupBrightness(groupId) {
        const group = getGroupById(groupId);
        if (!group) return 0;
        const value = Number.parseInt(group.brightness, 10);
        if (!Number.isFinite(value)) return 0;
        return Math.max(0, Math.min(100, value));
      }

      function setActiveGroup(groupId) {
        lastActiveGroupId = groupId || null;
        if (!brightnessSlider) return;
        if (!groupId) {
          brightnessSlider.disabled = true;
          brightnessSlider.value = 0;
          if (brightnessValue) brightnessValue.textContent = "0";
          return;
        }
        const avg = getGroupBrightness(groupId);
        brightnessSlider.disabled = false;
        brightnessSlider.value = String(avg);
        if (brightnessValue) brightnessValue.textContent = String(avg);
      }

      function renderSwitchButtons(selectedValue) {
        if (!switchButtonLayer) {
          console.log("No switch button layer");
          return;
        }
        switchButtonLayer.innerHTML = "";
        const entry = findSwitchByValue(selectedValue);
        if (!entry) {
          setActiveGroup(null);
          return;
        }
        const count = SWITCH_BUTTON_POSITIONS[getSwitchButtonCount(entry)] ? getSwitchButtonCount(entry) : 5;
        const positions = SWITCH_BUTTON_POSITIONS[count] || SWITCH_BUTTON_POSITIONS[5];
        const buttons = findButtonsForSwitch(entry);
        const maxButtons = Math.min(positions.length, buttons.length || positions.length);
        for (let i = 0; i < maxButtons; i += 1) {
          const button = buttons[i] || {};
          const pos = positions[i];
          const el = document.createElement("div");
          el.className = "switch-button";
          el.style.left = `${pos.x}%`;
          el.style.top = `${pos.y}%`;
          const mask = button.mask ?? (1 << i);
          const group = getGroupById(button.group_id);
          if (group?.is_on) {
            el.classList.add("is-on");
          }
          el.title = button.name || `Button ${i + 1}`;
          el.dataset.switch = entry.switch ?? "";
          el.dataset.mask = mask;
          el.dataset.groupId = button.group_id || "";
          el.addEventListener("pointerdown", handleButtonDown);
          el.addEventListener("pointerup", handleButtonUp);
          el.addEventListener("pointerleave", handleButtonUp);
          switchButtonLayer.appendChild(el);
        }
      }

      function renderSwitchDropdown() {
        if (!switchSelect) return;
        const entries = state.switches || [];
        const previous = switchSelect.value;
        if (!entries.length) {
          switchSelect.innerHTML = '<option value="">No switches configured</option>';
          switchSelect.disabled = true;
          renderSwitchButtons(null);
          setActiveGroup(null);
          return;
        }
        const sorted = entries.slice().sort((a, b) => {
          const aVal = Number(a.switch);
          const bVal = Number(b.switch);
          if (Number.isFinite(aVal) && Number.isFinite(bVal) && aVal !== bVal) {
            return aVal - bVal;
          }
          return (a.name || "").localeCompare(b.name || "");
        });
        const options = ['<option value="">Select a switch</option>'].concat(
          sorted.map((entry) => {
            const sw = entry.switch ?? "";
            const label = entry.name || (Number.isFinite(Number(sw)) ? `Switch ${sw}` : String(sw || "Switch"));
            return `<option value="${sw}">${label}</option>`;
          })
        );
        switchSelect.innerHTML = options.join("");
        switchSelect.disabled = false;
        if (previous && options.some((opt) => opt.includes(`value="${previous}"`))) {
          switchSelect.value = previous;
        }
        renderSwitchButtons(switchSelect.value || null);
        renderLedMatrix();
      }

      function renderControllers() {
        const summaries = computeControllerSummaries();

        if (!summaries.length) {
          statusEl.textContent = "No controllers available.";
          listEl.innerHTML = "";
          return;
        }

        statusEl.textContent = `Showing ${summaries.length} controller${summaries.length === 1 ? "" : "s"}.`;
        listEl.innerHTML = summaries
          .map((controller) => {
            const power = formatNumber(controller.power, 2);
            const current = formatNumber(controller.current, 2);
            const voltage = formatNumber(controller.voltage, 2);
            return `
              <tr>
                <td>${controller.name}</td>
                <td class="power">${power} W</td>
                <td>${controller.led_on}</td>
                <td>${controller.led_fault}</td>
                <td>${controller.led_total}</td>
                <td>${current} A</td>
                <td>${voltage} V</td>
              </tr>
            `;
          })
          .join("");
      }

      let refreshTimer = null;
      const REFRESH_INTERVAL_MS = 5000;
      let wsUnsubs = [];
      const toggleRefreshEl = document.getElementById("toggle-refresh");
      const manualRefreshEl = document.getElementById("manual-refresh");
      const HOLD_MS = 350;
      const DBL_MS = 250;

      function scheduleRefresh() {
        if (refreshTimer !== null) {
          console.log("Clearing existing refresh timer");
          clearInterval(refreshTimer);
          refreshTimer = null;
        }
        if (toggleRefreshEl && !toggleRefreshEl.checked) {
          return;
        }
        refreshTimer = setInterval(() => {
          if (document.hidden) {
            return;
          }
          refreshData();
        }, REFRESH_INTERVAL_MS);
      }

      async function refreshData() {
        if (!state.entryId) {
          return;
        }
        try {
          const registry = await callApi("get", `/api/s2j_led_driver/${state.entryId}/registry`);
          state.controllers = registry.controllers || [];
          state.drivers = registry.drivers || [];
          state.switches = registry.switches || [];
          state.groups = registry.groups || [];
          state.buttons = registry.buttons || [];
          renderSwitchDropdown();
          renderControllers();
          renderSwitchButtons(switchSelect.value || null);
          renderLedMatrix();
          if (lastActiveGroupId) {
            setActiveGroup(lastActiveGroupId);
          }
        } catch (error) {
          console.error(error);
          statusEl.textContent = error.message || "Failed to refresh controller data.";
        }
      }

      function buildLedEntries() {
        const groupMap = new Map();
        (state.groups || []).forEach((group) => {
          (group.led_ids || []).forEach((id) => {
            if (!groupMap.has(id)) {
              groupMap.set(id, []);
            }
            groupMap.get(id).push(group.name || group.id);
          });
        });

        const entries = [];
        (state.drivers || []).forEach((driver) => {
          const controllerId = driver.controller_id;
          const driverIndex = driver.driver_index;
          (driver.outputs || []).forEach((output) => {
            if (output.disabled) return;
            const id = output.id;
            const name = output.name || id || "LED";
            const on = Number(output.level || 0) > 0;
            const faulty = !!output.faulty;
            const groups = groupMap.get(id) || [];
            //console.log("LED id:",id," on:",on," level:",output.level," pwm:",output.target_pwm," min:",output.min_pwm," faulty:",faulty," groups:",groups);
            entries.push({
              id,
              name,
              controllerId,
              driverIndex,
              on,
              faulty,
              groups,
              min_pwm: output.min_pwm,
              max_pwm: output.max_pwm,
              pwm: output.target_pwm,
            });
          });
        });
        return entries;
      }

      async function toggleLed(entry) {
        if (!entry?.id) return;
        try {
          await sendOutputState(entry.id, !entry.on);
          entry.on = !entry.on;
          renderLedMatrix();
        } catch (error) {
          console.error("Failed to toggle LED", entry.id, error);
        }
      }

      function renderLedMatrix() {
        if (!ledGrid) return;
        const entries = buildLedEntries();
        if (!entries.length) {
          ledGrid.innerHTML = "<p style=\"margin:0;color:rgba(229,231,235,0.7)\">No LEDs detected.</p>";
          return;
        }
        const dots = entries
          .map((entry) => {
            const cls = ["led-dot"];
            if (entry.faulty) {
              cls.push("fault");
            } else if (entry.on) {
              cls.push("on");
            }
            const groups = entry.groups.join(", ") || "No group";
            const tooltip = `${entry.name}\nGroups: ${groups}`;
            return `<div class="${cls.join(" ")}" data-output="${entry.id}" data-tooltip="${tooltip.replace(/"/g, "&quot;")}"></div>`;
          })
          .join("");
        ledGrid.innerHTML = dots;
        ledGrid.querySelectorAll(".led-dot").forEach((dot, index) => {
          const entry = entries[index];
          dot.addEventListener("click", () => toggleLed(entry));
        });
      }

      if (toggleRefreshEl){
        toggleRefreshEl.addEventListener("change", () => {
          console.log("Auto refresh toggled:", toggleRefreshEl.checked);
          if (toggleRefreshEl.checked) {
            scheduleRefresh();
          } else if (refreshTimer !== null) {
            console.log("Clearing existing refresh timer due to disable");
            clearInterval(refreshTimer);
            refreshTimer = null;
          }
        });
      }

      if (manualRefreshEl) {
        manualRefreshEl.addEventListener("click", () => {
          refreshData();
        });
      }

      async function fetchRegistry() {
        const entries = await callApi("get", "/api/s2j_led_driver/entries");
        if (!entries?.length) {
          throw new Error("No LED Driver integrations found.");
        }
        const entry = entries[0];
        state.entryId = entry.entry_id;
        const snapshot = await callApi("get", `/api/s2j_led_driver/${state.entryId}/registry`);
        state.controllers = snapshot.controllers || [];
        state.drivers = snapshot.drivers || [];
        state.switches = snapshot.switches || [];
        state.groups = snapshot.groups || [];
        state.buttons = snapshot.buttons || [];
        renderLedMatrix();
      }

      async function loadData() {
        try {
          statusEl.textContent = "Loading…";
          await waitForHass();
          await fetchRegistry();
          renderSwitchDropdown();
          renderSwitchButtons(switchSelect.value || null);
          renderControllers();
          startWebsocket();
          scheduleRefresh();
          if (panelVersionEl) {
            panelVersionEl.textContent = window.LED_DRIVER_PANEL_VERSION || "unknown";
          }
        } catch (error) {
          console.error(error);
          statusEl.textContent = error.message || "Failed to load controller data.";
        }
      }

      document.addEventListener("visibilitychange", () => {
        if (!document.hidden) {
          refreshData();
        }
      });

      if (switchSelect) {
        switchSelect.addEventListener("change", (event) => {
          renderSwitchButtons(event.target.value || null);
        });
      }

      function startWebsocket() {
        try {
          const hass = resolveHass();
          const connection = hass?.connection;
          if (!connection || wsUnsubs.length) {
            return;
          }
          const unsubState = connection.subscribeEvents((event) => {
            const entityId = event?.data?.entity_id;
            console.debug("LED driver overview: websocket event", event);
            if (typeof entityId === "string" && entityId.includes("s2j_led_driver")) {
              const applied = applyStateChangeFromEvent(event);
              if (!applied) {
                refreshData().catch((err) => console.error("LED driver overview: refresh failed", err));
              }
            } else {
              console.debug("LED driver overview: ignoring unrelated event for", entityId);
            }
          }, "state_changed");
          const unsubCustom = connection.subscribeEvents((event) => {
            console.debug("LED driver overview: custom event", event);
            if (!applyGroupBusEvent(event?.data)) {
              refreshData().catch((err) => console.error("LED driver overview: refresh failed", err));
            }
          }, "s2j_led_driver_group_state");
          wsUnsubs = [unsubState, unsubCustom];
          console.debug("LED driver overview: WebSocket subscription active");
        } catch (error) {
          console.debug("LED driver overview: failed to start WebSocket subscription", error);
        }
      }

      let sliderDebounce = null;
      if (brightnessSlider) {
        brightnessSlider.addEventListener("input", () => {
          const value = Number(brightnessSlider.value || 0) || 0;
          if (brightnessValue) brightnessValue.textContent = String(value);
        });
        brightnessSlider.addEventListener("change", () => {
          if (!lastActiveGroupId || brightnessSlider.disabled) return;
          const value = Number(brightnessSlider.value || 0) || 0;
          if (sliderDebounce) {
            clearTimeout(sliderDebounce);
          }
          sliderDebounce = setTimeout(async () => {
            try {
              await applyGroupBrightness(lastActiveGroupId, value);
            } catch (err) {
              console.error(err);
            }
          }, 60);
        });
      }

      function getButtonState(switchValue, mask) {
        const key = buttonStateKey(switchValue, mask);
        if (!buttonInteractionState.has(key)) {
          buttonInteractionState.set(key, {
            direction: 1,
            holdTimer: null,
            rampTimer: null,
            clickTimer: null,
            holdActive: false,
            doubleActive: false,
            firstClickDone: false,
            pressed: false,
          });
        }
        return buttonInteractionState.get(key);
      }

      async function applyGroupBrightness(groupId, pwmValue) {
        const outputs = getGroupOutputs(groupId);
        if (!outputs.length) return;
        const brightness = Math.max(0, Math.min(100, Number(pwmValue) || 0));
        const targets = {};
        outputs.forEach((out) => {
          const min_pwm = Number(out.min_pwm ?? 0) || 0;
          const max_pwm = Number(out.max_pwm ?? 255) || 255;
          const range = Math.max(0, max_pwm - min_pwm);
          const pwm = Math.round(min_pwm + range * (brightness / 100));
          targets[out.id] = pwm;
        });
        await sendGroupPwmTargets(groupId, targets, brightness);
        const group = getGroupById(groupId);
        if (group) {
          group.brightness = brightness;
        }
      }

      async function sendGroupAction(groupId, action) {
        console.debug("LED driver overview: sending group action", { groupId, action });
        await callApi(
          "post",
          `/api/s2j_led_driver/${state.entryId}/command`,
          {
            command: "set_group",
            group_id: groupId,
            action,
          }
        );
      }

      async function sendGroupPwmTargets(groupId, targets, brightness) {
        console.debug("LED driver overview: sending group PWM targets", { groupId, targets, brightness });
        await callApi(
          "post",
          `/api/s2j_led_driver/${state.entryId}/command`,
          {
            command: "set_group_pwm",
            group_id: groupId,
            targets,
            brightness,
          }
        );
      }

      async function sendOutputPwm(outputId, pwm) {
        console.debug("LED driver overview: sending output PWM", { outputId, pwm });
        await callApi(
          "post",
          `/api/s2j_led_driver/${state.entryId}/command`,
          {
            command: "set_output_pwm",
            output_id: outputId,
            pwm,
          }
        );
      }

      async function sendOutputState(outputId, turnOn) {
        console.debug("LED driver overview: sending output state", { outputId, turnOn });
        await callApi(
          "post",
          `/api/s2j_led_driver/${state.entryId}/command`,
          {
            command: "set_output_state",
            output_id: outputId,
            on: turnOn,
          }
        );
      }

      async function ensureGroupOn(groupId) {
        const group = getGroupById(groupId);
        if (group && group.is_on) {
          return;
        }
        await sendGroupAction(groupId, "on");
        await refreshData();
      }

      function computePwmStepTargets(groupId, direction) {
        const group = getGroupById(groupId);
        if (!group) return null;
        const ledIds = group.led_ids || [];
        if (!ledIds.length) return null;
        const outputIndex = buildOutputIndex();
        const targets = {};
        ledIds.forEach((outputId) => {
          const record = outputIndex.get(outputId);
          if (!record) return;
          const { output } = record;
          const current = Number(output.pwm ?? output.target_pwm ?? 0) || 0;
          const min_pwm = Number(output.min_pwm ?? 0) || 0;
          const max_pwm = Number(output.max_pwm ?? 255) || 255;
          const step = direction >= 0 ? 1 : -1;
          let next = current + step;
          if (direction >= 0) {
            next = Math.min(next, max_pwm);
          } else {
            next = Math.max(next, min_pwm);
          }
          if (next !== current) {
            targets[outputId] = next;
          }
        });
        return Object.keys(targets).length ? targets : null;
      }

      async function stepGroupPwm(groupId, direction) {
        const targets = computePwmStepTargets(groupId, direction);
        if (!targets) {
          return false;
        }
        await sendGroupPwmTargets(groupId, targets);
        return true;
      }

      function bumpSlider(direction) {
        if (!brightnessSlider || brightnessSlider.disabled) return null;
        const step = direction >= 0 ? 3 : -3;
        const current = Number(brightnessSlider.value || 0) || 0;
        const next = Math.min(100, Math.max(0, current + step));
        brightnessSlider.value = String(next);
        if (brightnessValue) brightnessValue.textContent = String(next);
        return next;
      }

      function handleButtonDown(event) {
        event.preventDefault();
        const el = event.currentTarget;
        const switchValue = el.dataset.switch;
        const mask = el.dataset.mask;
        const groupId = el.dataset.groupId;
        if (!groupId) {
          return;
        }
        setActiveGroup(groupId);
        const stateObj = getButtonState(switchValue, mask);
        // Second press while single is pending => treat as double
        if (stateObj.clickTimer && !stateObj.doubleActive) {
          clearTimeout(stateObj.clickTimer);
          stateObj.clickTimer = null;
          stateObj.doubleActive = true;
        }
        stateObj.pressed = true;
        stateObj.holdActive = false;
        if (stateObj.holdTimer) {
          clearTimeout(stateObj.holdTimer);
          stateObj.holdTimer = null;
        }
        stateObj.holdTimer = setTimeout(async () => {
          stateObj.holdTimer = null;
          if (!stateObj.pressed) return;
          // On second press+hold, flip direction; otherwise keep last direction
          if (stateObj.doubleActive) {
            stateObj.direction = stateObj.direction === 1 ? -1 : 1;
          }
          stateObj.holdActive = true;
          await ensureGroupOn(groupId);
          stateObj.rampTimer = setInterval(async () => {
            if (!stateObj.pressed) {
              clearInterval(stateObj.rampTimer);
              stateObj.rampTimer = null;
              return;
            }
            const next = bumpSlider(stateObj.direction);
            if (next !== null) {
              await applyGroupBrightness(groupId, next);
            }
          }, 300);
        }, HOLD_MS);
      }

      function handleButtonUp(event) {
        const el = event.currentTarget;
        const switchValue = el.dataset.switch;
        const mask = el.dataset.mask;
        const groupId = el.dataset.groupId;
        const stateObj = getButtonState(switchValue, mask);
        if (stateObj.holdTimer) {
          clearTimeout(stateObj.holdTimer);
          stateObj.holdTimer = null;
        }
        const wasPress = stateObj.pressed;
        stateObj.pressed = false;

        if (stateObj.rampTimer) {
          clearInterval(stateObj.rampTimer);
          stateObj.rampTimer = null;
        }

        // If hold path was active, just stop bumping
        if (stateObj.holdActive) {
          stateObj.holdActive = false;
          resetButtonState(stateObj);
          return;
        }

        if (!wasPress || !groupId) {
          resetButtonState(stateObj);
          return;
        }

        // Double-click path (no hold)
        if (stateObj.doubleActive) {
          setActiveGroup(groupId);
          resetButtonState(stateObj);
          return;
        }

        // First click complete; wait for possible second click
        if (!stateObj.firstClickDone) {
          stateObj.firstClickDone = true;
          stateObj.clickTimer = setTimeout(() => {
            stateObj.clickTimer = null;
            stateObj.firstClickDone = false;
            const group = getGroupById(groupId);
            const action = group && group.is_on ? "off" : "on";
            setActiveGroup(groupId);
            sendGroupAction(groupId, action).catch(console.error);
            resetButtonState(stateObj);
          }, DBL_MS);
          return;
        }

        resetButtonState(stateObj);
      }

      function resetButtonState(stateObj) {
        if (!stateObj) return;
        if (stateObj.holdTimer) {
          clearTimeout(stateObj.holdTimer);
          stateObj.holdTimer = null;
        }
        if (stateObj.clickTimer) {
          clearTimeout(stateObj.clickTimer);
          stateObj.clickTimer = null;
        }
        if (stateObj.rampTimer) {
          clearInterval(stateObj.rampTimer);
          stateObj.rampTimer = null;
        }
        stateObj.holdActive = false;
        stateObj.doubleActive = false;
        stateObj.firstClickDone = false;
        stateObj.pressed = false;
      }

      loadData();
    </script>
  </body>
</html>
